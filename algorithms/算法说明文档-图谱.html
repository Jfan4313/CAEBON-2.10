<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®—æ³•è¯´æ˜æ–‡æ¡£ - å›¾è°±è§†å›¾</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252525;
            --bg-tertiary: #2d2d2d;
            --text-primary: #dcddde;
            --text-secondary: #a8a8a8;
            --accent: #7b6cd1;
            --border: #444444;

            /* èŠ‚ç‚¹é¢œè‰² */
            --node-algo: #7b6cd1;
            --node-param: #4ade80;
            --node-data: #ff6b6b;
            --node-core: #ffd93d;
            --node-advanced: #ff9ff3;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f3f4f6;
            --bg-tertiary: #e5e7eb;
            --text-primary: #1f1f1f;
            --text-secondary: #6b6b6b;
            --accent: #5c6bc0;
            --border: #e0e0e0;

            --node-algo: #5c6bc0;
            --node-param: #22c55e;
            --node-data: #ef4444;
            --node-core: #f59e0b;
            --node-advanced: #8b5cf6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* ä¾§è¾¹æ  */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-title {
            font-size: 1.3em;
            color: var(--accent);
            margin-bottom: 5px;
        }

        .sidebar-subtitle {
            font-size: 0.8em;
            color: var(--text-secondary);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .node-info-panel {
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin: 10px 0;
        }

        .node-info-title {
            font-size: 1.1em;
            color: var(--text-primary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-info-connections {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .connection-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            gap: 8px;
        }

        .connection-type {
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }

        .type-forward {
            background: rgba(123, 108, 209, 0.2);
            color: var(--node-algo);
        }

        .type-backward {
            background: rgba(255, 107, 107, 0.2);
            color: var(--node-data);
        }

        .sidebar-footer {
            padding: 15px;
            border-top: 1px solid var(--border);
            font-size: 0.8em;
            color: var(--text-secondary);
        }

        /* å›¾è°±å®¹å™¨ */
        .graph-container {
            position: fixed;
            left: 280px;
            top: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            cursor: grab;
        }

        .graph-container:active {
            cursor: grabbing;
        }

        /* å›¾è°±ç”»å¸ƒ */
        #graphCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .control-btn {
            width: 45px;
            height: 45px;
            border-radius: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: var(--accent);
            color: white;
            transform: scale(1.1);
        }

        /* å›¾ä¾‹ */
        .legend {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 15px;
            z-index: 1000;
            max-height: 400px;
            overflow-y: auto;
        }

        .legend-title {
            font-size: 0.9em;
            color: var(--text-primary);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            gap: 8px;
            font-size: 0.85em;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .legend-label {
            color: var(--text-secondary);
        }

        /* æœç´¢æ¡† */
        .search-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            margin-top: 220px;
            z-index: 1000;
        }

        .search-input {
            padding: 10px 15px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            width: 200px;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(123, 108, 209, 0.3);
        }

        /* èŠ‚ç‚¹æç¤ºæ¡† */
        .tooltip {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            z-index: 2000;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-size: 1em;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .tooltip-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .tooltip-desc {
            font-size: 0.85em;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .tooltip-connections {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
        }

        .tooltip-conn {
            font-size: 0.8em;
            padding: 3px 0;
            color: var(--text-secondary);
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }
            .graph-container {
                left: 0;
            }
            .legend, .search-panel {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- ä¾§è¾¹æ  -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">ğŸ“Š ç®—æ³•å›¾è°±</div>
            <div class="sidebar-subtitle">å¯è§†åŒ–åŒé“¾å…³ç³»</div>
        </div>

        <div class="sidebar-content">
            <div id="nodeInfo" class="node-info-panel" style="display: none;">
                <div class="node-info-title">
                    <span class="node-indicator">â—</span>
                    <span id="selectedNodeName">é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹</span>
                </div>
                <div class="node-info-connections" id="nodeConnections">
                    ç‚¹å‡»å›¾è°±ä¸­çš„èŠ‚ç‚¹æŸ¥çœ‹è¯¦æƒ…
                </div>
            </div>
        </div>

        <div class="sidebar-footer">
            <p>ğŸ–±ï¸ æ‹–æ‹½ç”»å¸ƒç§»åŠ¨</p>
            <p>ğŸ” æ»šè½®ç¼©æ”¾è§†å›¾</p>
            <p>ğŸ–±ï¸ æ‹–æ‹½èŠ‚ç‚¹é‡æ–°å¸ƒå±€</p>
        </div>
    </aside>

    <!-- å›¾è°±å®¹å™¨ -->
    <div class="graph-container" id="graphContainer">
        <canvas id="graphCanvas"></canvas>
    </div>

    <!-- æ§åˆ¶æŒ‰é’® -->
    <div class="controls">
        <button class="control-btn" onclick="resetView()" title="é‡ç½®è§†å›¾">âŸ²</button>
        <button class="control-btn" onclick="togglePhysics()" id="physicsBtn" title="åˆ‡æ¢ç‰©ç†æ¨¡æ‹Ÿ">âš¡</button>
        <button class="control-btn" onclick="fitToScreen()" title="é€‚é…å±å¹•">â›¶</button>
        <button class="control-btn" onclick="toggleLayout()" id="layoutBtn" title="åˆ‡æ¢å¸ƒå±€">ğŸ”€</button>
    </div>

    <!-- å›¾ä¾‹ -->
    <div class="legend">
        <div class="legend-title">èŠ‚ç‚¹ç±»å‹</div>
        <div class="legend-item">
            <div class="legend-color" style="background: var(--node-algo);"></div>
            <span class="legend-label">ç®—æ³•åŠŸèƒ½</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: var(--node-param);"></div>
            <span class="legend-label">å‚æ•°é…ç½®</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: var(--node-data);"></div>
            <span class="legend-label">åŸºç¡€æ•°æ®</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: var(--node-core);"></div>
            <span class="legend-label">æ ¸å¿ƒç®—æ³•</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: var(--node-advanced);"></div>
            <span class="legend-label">é«˜çº§åŠŸèƒ½</span>
        </div>
    </div>

    <!-- æœç´¢æ¡† -->
    <div class="search-panel">
        <input type="text" class="search-input" id="searchInput" placeholder="æœç´¢èŠ‚ç‚¹...">
    </div>

    <!-- æç¤ºæ¡† -->
    <div class="tooltip" id="tooltip">
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-type" id="tooltipType"></div>
        <div class="tooltip-desc" id="tooltipDesc"></div>
        <div class="tooltip-connections" id="tooltipConnections"></div>
    </div>

    <script>
        // èŠ‚ç‚¹æ•°æ®
        const nodes = [
            // æ ¸å¿ƒèŠ‚ç‚¹
            { id: 'overview', label: 'æ¦‚è¿°', type: 'core', x: 0, y: 0, connections: ['lighting', 'hvac', 'solar', 'integrated', 'pmv', 'v2g', 'battery', 'digital-twin'], description: 'ç®—æ³•åº“æ•´ä½“ä»‹ç»' },
            { id: 'integrated', label: 'ç»¼åˆä¼˜åŒ–', type: 'algo', x: 0, y: 0, connections: ['lighting', 'hvac', 'solar', 'rl'], description: 'å¤šç³»ç»ŸååŒä¼˜åŒ–' },

            // ç…§æ˜ç³»ç»Ÿ
            { id: 'lighting', label: 'ç…§æ˜ç³»ç»Ÿ', type: 'algo', x: 0, y: 0, connections: ['baseline', 'savings'], description: 'ç…§æ˜åŸºå‡†å’ŒèŠ‚èƒ½è®¡ç®—' },
            { id: 'baseline', label: 'åŸºå‡†è®¡ç®—', type: 'algo', x: 0, y: 0, connections: [], description: 'calculateLightingBaseline' },
            { id: 'savings', label: 'èŠ‚èƒ½æ½œåŠ›', type: 'algo', x: 0, y: 0, connections: ['led', 'smart'], description: 'calculateLightingSavings' },
            { id: 'led', label: 'LEDå‡çº§', type: 'param', x: 0, y: 0, connections: [], description: 'ä»ç™½ç‚½ç¯åˆ°LED' },
            { id: 'smart', label: 'æ™ºèƒ½æ§åˆ¶', type: 'param', x: 0, y: 0, connections: ['light-sensor'], description: 'å…‰æ„Ÿ+è°ƒå…‰ç³»ç»Ÿ' },
            { id: 'light-sensor', label: 'å…‰ç…§ä¼ æ„Ÿå™¨', type: 'param', x: 0, y: 0, connections: [], description: 'ä¼ æ„Ÿå™¨å®‰è£…å¯†åº¦' },

            // æš–é€šç©ºè°ƒ
            { id: 'hvac', label: 'æš–é€šç©ºè°ƒ', type: 'algo', x: 0, y: 0, connections: ['hvac-baseline', 'hvac-savings', 'thermal-coef'], description: 'ç©ºè°ƒåŸºå‡†å’ŒèŠ‚èƒ½è®¡ç®—' },
            { id: 'hvac-baseline', label: 'ç©ºè°ƒåŸºå‡†', type: 'algo', x: 0, y: 0, connections: [], description: 'calculateHVACBaseline' },
            { id: 'hvac-savings', label: 'ç©ºè°ƒèŠ‚èƒ½', type: 'algo', x: 0, y: 0, connections: ['cop', 'fresh-air'], description: 'calculateHVACSavings' },
            { id: 'cop', label: 'COPæå‡', type: 'param', x: 0, y: 0, connections: [], description: 'èƒ½æ•ˆç³»æ•°æå‡' },
            { id: 'fresh-air', label: 'æ–°é£ç³»ç»Ÿ', type: 'param', x: 0, y: 0, connections: [], description: 'æ–°é£ç³»ç»Ÿæ•ˆç‡' },
            { id: 'thermal-coef', label: 'çƒ­å¯¼ç³»æ•°', type: 'data', x: 0, y: 0, connections: [], description: 'å»ºç­‘çƒ­å¯¼ç³»æ•°å¸¸é‡' },

            // å…‰å‚¨ç³»ç»Ÿ
            { id: 'solar', label: 'å…‰å‚¨ç³»ç»Ÿ', type: 'algo', x: 0, y: 0, connections: ['pv', 'storage-opt', 'battery-degrad'], description: 'å…‰ä¼å’Œå‚¨èƒ½ä¼˜åŒ–' },
            { id: 'pv', label: 'å…‰ä¼å‘ç”µ', type: 'algo', x: 0, y: 0, connections: ['sunshine', 'weather'], description: 'calculateSolarGeneration' },
            { id: 'storage-opt', label: 'å‚¨èƒ½ä¼˜åŒ–', type: 'algo', x: 0, y: 0, connections: ['price-curve', 'arbitrage'], description: 'calculateStorageOptimization' },
            { id: 'sunshine', label: 'æ—¥ç…§æ•°æ®', type: 'data', x: 0, y: 0, connections: ['cities'], description: 'åŸå¸‚å¹´æ—¥ç…§æ—¶æ•°' },
            { id: 'weather', label: 'å¤©æ°”å› ç´ ', type: 'param', x: 0, y: 0, connections: [], description: 'äº‘é‡ã€æ¸©åº¦ã€è¾å°„' },
            { id: 'cities', label: 'åŸå¸‚æ•°æ®', type: 'data', x: 0, y: 0, connections: [], description: '20+åŸå¸‚æ—¥ç…§æ•°æ®' },
            { id: 'price-curve', label: 'ç”µä»·æ›²çº¿', type: 'param', x: 0, y: 0, connections: [], description: 'å³°è°·å¹³ç”µä»·' },
            { id: 'arbitrage', label: 'å³°è°·å¥—åˆ©', type: 'param', x: 0, y: 0, connections: [], description: 'è°·å……å³°æ”¾ç­–ç•¥' },
            { id: 'battery-degrad', label: 'ç”µæ± è¡°å‡', type: 'algo', x: 0, y: 0, connections: ['battery-type', 'cycle-count'], description: 'calculateBatteryDegradation' },
            { id: 'battery-type', label: 'ç”µæ± ç±»å‹', type: 'param', x: 0, y: 0, connections: [], description: 'LFP/NCM/é“…é…¸' },
            { id: 'cycle-count', label: 'å¾ªç¯æ¬¡æ•°', type: 'param', x: 0, y: 0, connections: [], description: 'ç´¯è®¡å……æ”¾ç”µå¾ªç¯' },

            // èˆ’é€‚åº¦è®¡ç®—
            { id: 'pmv', label: 'èˆ’é€‚åº¦è®¡ç®—', type: 'advanced', x: 0, y: 0, connections: ['pmv-fn', 'ppd-fn', 'comfort-metrics'], description: 'PMV/PPDèˆ’é€‚åº¦è¯„ä¼°' },
            { id: 'pmv-fn', label: 'PMVå‡½æ•°', type: 'algo', x: 0, y: 0, connections: ['fanger'], description: 'é¢„æµ‹å¹³å‡æŠ•ç¥¨å€¼' },
            { id: 'ppd-fn', label: 'PPDå‡½æ•°', type: 'algo', x: 0, y: 0, connections: ['fanger'], description: 'é¢„æµ‹ä¸æ»¡æ„ç™¾åˆ†æ¯”' },
            { id: 'comfort-metrics', label: 'ç»¼åˆæŒ‡æ ‡', type: 'algo', x: 0, y: 0, connections: [], description: 'èˆ’é€‚åº¦æŒ‡æ ‡ç»¼åˆ' },
            { id: 'fanger', label: 'Fangeræ–¹ç¨‹', type: 'data', x: 0, y: 0, connections: [], description: 'çƒ­èˆ’é€‚åº¦è®¡ç®—æ¨¡å‹' },

            // V2G
            { id: 'v2g', label: 'V2Gäº¤äº’', type: 'advanced', x: 0, y: 0, connections: ['v2g-opt', 'ev-device'], description: 'è½¦è¾†åˆ°ç”µç½‘äº¤äº’ä¼˜åŒ–' },
            { id: 'v2g-opt', label: 'V2Gè°ƒåº¦', type: 'algo', x: 0, y: 0, connections: ['soc', 'priority'], description: 'calculateV2GOptimization' },
            { id: 'ev-device', label: 'EVè®¾å¤‡', type: 'param', x: 0, y: 0, connections: [], description: 'å®¹é‡ã€åŠŸç‡ã€SOC' },
            { id: 'soc', label: 'SOCçŠ¶æ€', type: 'param', x: 0, y: 0, connections: [], description: 'ç”µæ± è·ç”µçŠ¶æ€' },
            { id: 'priority', label: 'ç”¨æˆ·ä¼˜å…ˆçº§', type: 'param', x: 0, y: 0, connections: [], description: 'low/medium/high' },

            // æ•°å­—å­ªç”Ÿ
            { id: 'digital-twin', label: 'æ•°å­—å­ªç”Ÿ', type: 'advanced', x: 0, y: 0, connections: ['thermal-model', 'hvac-response'], description: 'å»ºç­‘çƒ­çŠ¶æ€æ¨¡æ‹Ÿ' },
            { id: 'thermal-model', label: 'çƒ­æ¨¡å‹', type: 'param', x: 0, y: 0, connections: ['inertia', 'capacity'], description: 'å»ºç­‘çƒ­å‚æ•°' },
            { id: 'inertia', label: 'çƒ­æƒ¯æ€§', type: 'param', x: 0, y: 0, connections: [], description: 'å°æ—¶å•ä½' },
            { id: 'capacity', label: 'çƒ­å®¹é‡', type: 'param', x: 0, y: 0, connections: [], description: 'kJ/Kå•ä½' },
            { id: 'hvac-response', label: 'HVACå“åº”', type: 'param', x: 0, y: 0, connections: [], description: 'å“åº”æ—¶é—´å’Œæ­»åŒº' },

            // å¼ºåŒ–å­¦ä¹ 
            { id: 'rl', label: 'å¼ºåŒ–å­¦ä¹ ', type: 'advanced', x: 0, y: 0, connections: ['dqn', 'state-space', 'action-space'], description: 'DQNä¼˜åŒ–ç­–ç•¥' },
            { id: 'dqn', label: 'DQNç®—æ³•', type: 'algo', x: 0, y: 0, connections: ['q-learning', 'neural-net'], description: 'æ·±åº¦Qç½‘ç»œ' },
            { id: 'state-space', label: 'çŠ¶æ€ç©ºé—´', type: 'param', x: 0, y: 0, connections: [], description: 'è´Ÿè·Ã—ç”µä»·Ã—æ¸©åº¦' },
            { id: 'action-space', label: 'åŠ¨ä½œç©ºé—´', type: 'param', x: 0, y: 0, connections: [], description: '[-10%, 0%, +10%]' },
            { id: 'q-learning', label: 'Q-Learning', type: 'data', x: 0, y: 0, connections: [], description: 'å¼ºåŒ–å­¦ä¹ åŸºç¡€ç®—æ³•' },
            { id: 'neural-net', label: 'ç¥ç»ç½‘ç»œ', type: 'data', x: 0, y: 0, connections: [], description: 'æ·±åº¦å­¦ä¹ ç½‘ç»œ' },

            // ç”µæ± ï¼ˆç‹¬ç«‹èŠ‚ç‚¹ï¼Œä¸V2Gå…±äº«ï¼‰
            { id: 'battery', label: 'ç”µæ± è¡°å‡', type: 'algo', x: 0, y: 0, connections: ['degrad-rate', 'health-score'], description: 'ç”µæ± å¥åº·çŠ¶æ€è¯„ä¼°' },
            { id: 'degrad-rate', label: 'è¡°å‡ç‡', type: 'param', x: 0, y: 0, connections: [], description: '%/1000æ¬¡å¾ªç¯' },
            { id: 'health-score', label: 'å¥åº·åº¦', type: 'param', x: 0, y: 0, connections: [], description: '0-100%èŒƒå›´' },
        ];

        // è·å–èŠ‚ç‚¹é¢œè‰²
        function getNodeColor(type) {
            const colors = {
                'algo': getComputedStyle(document.documentElement).getPropertyValue('--node-algo').trim(),
                'param': getComputedStyle(document.documentElement).getPropertyValue('--node-param').trim(),
                'data': getComputedStyle(document.documentElement).getPropertyValue('--node-data').trim(),
                'core': getComputedStyle(document.documentElement).getPropertyValue('--node-core').trim(),
                'advanced': getComputedStyle(document.documentElement).getPropertyValue('--node-advanced').trim()
            };
            return colors[type] || colors['algo'];
        }

        // Canvasè®¾ç½®
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let draggingNode = null;
        let draggingCanvas = false;
        let lastMouseX, lastMouseY;
        let physicsEnabled = true;
        let currentLayout = 'force';

        // åˆå§‹åŒ–èŠ‚ç‚¹ä½ç½®ï¼ˆåœ†å½¢å¸ƒå±€ï¼‰
        function initPositions() {
            const centerX = 0;
            const centerY = 0;
            const radius = Math.min(canvas.width, canvas.height) * 0.35;

            nodes.forEach((node, i) => {
                const angle = (2 * Math.PI * i) / nodes.length;
                node.x = centerX + radius * Math.cos(angle);
                node.y = centerY + radius * Math.sin(angle);
                node.vx = 0;
                node.vy = 0;
            });

            // å°†æ¦‚è¿°æ”¾åœ¨ä¸­å¿ƒ
            const overview = nodes.find(n => n.id === 'overview');
            if (overview) {
                overview.x = centerX;
                overview.y = centerY;
            }
        }

        // ç‰©ç†æ¨¡æ‹Ÿ
        function simulatePhysics() {
            const repulsionStrength = 50000;
            const attractionStrength = 0.01;
            const damping = 0.9;
            const minDist = 100;

            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];

                // æ–¥åŠ›ï¼ˆèŠ‚ç‚¹ä¹‹é—´ï¼‰
                for (let j = i + 1; j < nodes.length; j++) {
                    const other = nodes[j];
                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                    if (dist < minDist) {
                        const force = repulsionStrength / (dist * dist);
                        const fx = force * dx / dist;
                        const fy = force * dy / dist;

                        node.vx += fx;
                        node.vy += fy;
                        other.vx -= fx;
                        other.vy -= fy;
                    }
                }

                // å¼•åŠ›ï¼ˆè¿æ¥çš„èŠ‚ç‚¹ä¹‹é—´ï¼‰
                node.connections.forEach(connId => {
                    const connNode = nodes.find(n => n.id === connId);
                    if (connNode) {
                        const dx = connNode.x - node.x;
                        const dy = connNode.y - node.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        const fx = dx * attractionStrength;
                        const fy = dy * attractionStrength;

                        node.vx += fx;
                        node.vy += fy;
                        connNode.vx -= fx;
                        connNode.vy -= fy;
                    }
                });

                // ä¸­å¿ƒå¼•åŠ›
                node.vx -= node.x * 0.001;
                node.vy -= node.y * 0.001;

                // é˜»å°¼
                node.vx *= damping;
                node.vy *= damping;

                // æ›´æ–°ä½ç½®
                if (node.id !== 'overview') {
                    node.x += node.vx;
                    node.y += node.vy;
                }
            }
        }

        // ç»˜åˆ¶å›¾è°±
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
            ctx.scale(scale, scale);

            // ç»˜åˆ¶è¿æ¥çº¿
            nodes.forEach(node => {
                node.connections.forEach(connId => {
                    const connNode = nodes.find(n => n.id === connId);
                    if (connNode) {
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(connNode.x, connNode.y);
                        ctx.strokeStyle = 'rgba(123, 108, 209, 0.3)';
                        ctx.lineWidth = 1.5 / scale;
                        ctx.stroke();

                        // ç»˜åˆ¶ç®­å¤´
                        const angle = Math.atan2(connNode.y - node.y, connNode.x - node.x);
                        const arrowLength = 10;
                        ctx.beginPath();
                        ctx.moveTo(connNode.x, connNode.y);
                        ctx.lineTo(
                            connNode.x - arrowLength * Math.cos(angle - Math.PI / 6),
                            connNode.y - arrowLength * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.lineTo(
                            connNode.x - arrowLength * Math.cos(angle + Math.PI / 6),
                            connNode.y - arrowLength * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.strokeStyle = 'rgba(123, 108, 209, 0.5)';
                        ctx.stroke();
                    }
                });
            });

            // ç»˜åˆ¶èŠ‚ç‚¹
            nodes.forEach(node => {
                const color = getNodeColor(node.type);
                const baseRadius = node.id === 'overview' ? 35 : 25;

                // èŠ‚ç‚¹é˜´å½±
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;

                // ç»˜åˆ¶èŠ‚ç‚¹èƒŒæ™¯
                ctx.beginPath();
                ctx.arc(node.x, node.y, baseRadius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                ctx.shadowBlur = 0;

                // ç»˜åˆ¶èŠ‚ç‚¹è¾¹æ¡†
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // ç»˜åˆ¶èŠ‚ç‚¹æ ‡ç­¾
                ctx.fillStyle = '#ffffff';
                ctx.font = `${node.id === 'overview' ? '14' : '11'}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const maxWidth = baseRadius * 1.6;
                let label = node.label;
                if (ctx.measureText(label).width > maxWidth) {
                    while (ctx.measureText(label + '...').width > maxWidth && label.length > 2) {
                        label = label.slice(0, -1);
                    }
                    label += '...';
                }
                ctx.fillText(label, node.x, node.y);
            });

            ctx.restore();
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            if (physicsEnabled) {
                simulatePhysics();
            }
            draw();
            requestAnimationFrame(animate);
        }

        // è°ƒæ•´ç”»å¸ƒå¤§å°
        function resizeCanvas() {
            const container = document.getElementById('graphContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            initPositions();
        }

        // é¼ æ ‡äº‹ä»¶å¤„ç†
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - canvas.width / 2 - offsetX) / scale,
                y: (e.clientY - rect.top - canvas.height / 2 - offsetY) / scale
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            let clickedNode = null;

            for (const node of nodes) {
                const dx = pos.x - node.x;
                const dy = pos.y - node.y;
                const radius = node.id === 'overview' ? 35 : 25;
                if (Math.sqrt(dx * dx + dy * dy) < radius) {
                    clickedNode = node;
                    break;
                }
            }

            if (clickedNode) {
                draggingNode = clickedNode;
                showNodeInfo(clickedNode);
            } else {
                draggingCanvas = true;
            }
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);

            // æ›´æ–°æç¤ºæ¡†
            let hoveredNode = null;
            for (const node of nodes) {
                const dx = pos.x - node.x;
                const dy = pos.y - node.y;
                const radius = node.id === 'overview' ? 35 : 25;
                if (Math.sqrt(dx * dx + dy * dy) < radius) {
                    hoveredNode = node;
                    canvas.style.cursor = 'pointer';
                    break;
                }
            }

            if (hoveredNode) {
                showTooltip(e.clientX, e.clientY, hoveredNode);
            } else {
                hideTooltip();
                canvas.style.cursor = draggingCanvas ? 'grabbing' : (draggingNode ? 'grabbing' : 'grab');
            }

            if (draggingNode) {
                draggingNode.x = pos.x;
                draggingNode.y = pos.y;
                draggingNode.vx = 0;
                draggingNode.vy = 0;
            } else if (draggingCanvas) {
                offsetX += e.clientX - lastMouseX;
                offsetY += e.clientY - lastMouseY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggingNode = null;
            draggingCanvas = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            draggingNode = null;
            draggingCanvas = false;
            hideTooltip();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            scale *= zoomFactor;
            scale = Math.max(0.2, Math.min(3, scale));
        });

        // æ˜¾ç¤ºèŠ‚ç‚¹ä¿¡æ¯
        function showNodeInfo(node) {
            const infoPanel = document.getElementById('nodeInfo');
            const nodeName = document.getElementById('selectedNodeName');
            const connections = document.getElementById('nodeConnections');

            infoPanel.style.display = 'block';
            nodeName.textContent = node.label;

            const typeLabels = {
                'algo': 'ç®—æ³•åŠŸèƒ½',
                'param': 'å‚æ•°é…ç½®',
                'data': 'åŸºç¡€æ•°æ®',
                'core': 'æ ¸å¿ƒç®—æ³•',
                'advanced': 'é«˜çº§åŠŸèƒ½'
            };

            let connectionsHtml = `
                <div class="connection-item">
                    <span class="connection-type type-forward">ç±»å‹</span>
                    <span>${typeLabels[node.type]}</span>
                </div>
            `;

            if (node.connections && node.connections.length > 0) {
                connectionsHtml += '<div style="margin-top: 10px; color: var(--text-secondary); font-size: 0.9em;">è¿æ¥åˆ°:</div>';
                node.connections.forEach(connId => {
                    const connNode = nodes.find(n => n.id === connId);
                    if (connNode) {
                        connectionsHtml += `
                            <div class="connection-item">
                                <span class="connection-type type-forward">â†’</span>
                                <span>${connNode.label}</span>
                            </div>
                        `;
                    }
                });
            }

            if (node.connections && node.connections.length === 0) {
                connectionsHtml += '<div style="margin-top: 10px; color: var(--text-secondary); font-size: 0.85em;">æ— è¿æ¥ï¼ˆå¶å­èŠ‚ç‚¹ï¼‰</div>';
            }

            connections.innerHTML = connectionsHtml;
        }

        // æ˜¾ç¤ºæç¤ºæ¡†
        function showTooltip(x, y, node) {
            const tooltip = document.getElementById('tooltip');
            const title = document.getElementById('tooltipTitle');
            const type = document.getElementById('tooltipType');
            const desc = document.getElementById('tooltipDesc');
            const conns = document.getElementById('tooltipConnections');

            const typeLabels = {
                'algo': { text: 'ç®—æ³•åŠŸèƒ½', color: 'var(--node-algo)' },
                'param': { text: 'å‚æ•°é…ç½®', color: 'var(--node-param)' },
                'data': { text: 'åŸºç¡€æ•°æ®', color: 'var(--node-data)' },
                'core': { text: 'æ ¸å¿ƒç®—æ³•', color: 'var(--node-core)' },
                'advanced': { text: 'é«˜çº§åŠŸèƒ½', color: 'var(--node-advanced)' }
            };

            title.textContent = node.label;
            type.textContent = typeLabels[node.type].text;
            type.style.background = typeLabels[node.type].color;
            desc.textContent = node.description;

            if (node.connections && node.connections.length > 0) {
                const connNames = node.connections.slice(0, 5).map(id => {
                    const n = nodes.find(node => node.id === id);
                    return n ? n.label : id;
                }).join(', ');
                conns.innerHTML = `<div class="tooltip-conn">è¿æ¥: ${connNames}${node.connections.length > 5 ? '...' : ''}</div>`;
            } else {
                conns.innerHTML = '';
            }

            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // æ§åˆ¶å‡½æ•°
        function resetView() {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            initPositions();
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            document.getElementById('physicsBtn').style.background = physicsEnabled ? 'var(--accent)' : 'var(--bg-tertiary)';
            document.getElementById('physicsBtn').style.color = physicsEnabled ? 'white' : 'var(--text-primary)';
        }

        function fitToScreen() {
            const margin = 100;
            const maxX = Math.max(...nodes.map(n => n.x));
            const minX = Math.min(...nodes.map(n => n.x));
            const maxY = Math.max(...nodes.map(n => n.y));
            const minY = Math.min(...nodes.map(n => n.y));

            const width = maxX - minX + margin * 2;
            const height = maxY - minY + margin * 2;

            scale = Math.min(canvas.width / width, canvas.height / height);
            scale = Math.min(scale, 1.5);

            offsetX = -(minX + maxX) / 2;
            offsetY = -(minY + maxY) / 2;
        }

        function toggleLayout() {
            currentLayout = currentLayout === 'force' ? 'circular' : 'force';
            if (currentLayout === 'circular') {
                initCircularLayout();
            }
        }

        function initCircularLayout() {
            const centerX = 0;
            const centerY = 0;
            const radius = Math.min(canvas.width, canvas.height) * 0.35;

            nodes.forEach((node, i) => {
                const angle = (2 * Math.PI * i) / nodes.length;
                node.x = centerX + radius * Math.cos(angle);
                node.y = centerY + radius * Math.sin(angle);
                node.vx = 0;
                node.vy = 0;
            });

            const overview = nodes.find(n => n.id === 'overview');
            if (overview) {
                overview.x = centerX;
                overview.y = centerY;
            }
        }

        // æœç´¢åŠŸèƒ½
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();

            nodes.forEach(node => {
                const match = node.label.toLowerCase().includes(query) ||
                             node.description.toLowerCase().includes(query);
                node.highlighted = match;
            });
        });

        // åˆå§‹åŒ–
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();

        // é»˜è®¤å…³é—­ç‰©ç†æ¨¡æ‹Ÿä»¥ä¿æŒåœ†å½¢å¸ƒå±€
        setTimeout(() => {
            physicsEnabled = false;
            document.getElementById('physicsBtn').style.background = 'var(--bg-tertiary)';
            document.getElementById('physicsBtn').style.color = 'var(--text-primary)';
        }, 1000);
    </script>
</body>
</html>
